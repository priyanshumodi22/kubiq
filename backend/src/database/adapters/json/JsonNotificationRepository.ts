import fs from 'fs';
import path from 'path';
import { INotificationRepository } from '../../interfaces/INotificationRepository';
import { NotificationChannel } from '../../../types';

export class JsonNotificationRepository implements INotificationRepository {
  private dataDir: string;
  private channels: Map<string, NotificationChannel> = new Map();

  constructor() {
    this.dataDir = process.env.DATA_DIR || './data';
  }

  async initialize(): Promise<void> {
    this.loadChannels();
  }

  private loadChannels(): void {
    try {
      if (!fs.existsSync(this.dataDir)) {
          // ensure data dir exists
           fs.mkdirSync(this.dataDir, { recursive: true });
      }
      const dataFile = path.join(this.dataDir, 'notifications.json');
      if (fs.existsSync(dataFile)) {
        const fileContent = fs.readFileSync(dataFile, 'utf-8').trim();
        if (fileContent) {
          const channels = JSON.parse(fileContent);
          channels.forEach((channel: NotificationChannel) => {
            this.channels.set(channel.id, channel);
          });
          console.log(`üîî Repository Loaded ${this.channels.size} notification channels`);
        }
      }
    } catch (error) {
      console.error('‚ùå Error loading notification channels:', error);
    }
  }

  private saveChannels(): void {
    try {
      if (!fs.existsSync(this.dataDir)) {
        fs.mkdirSync(this.dataDir, { recursive: true });
      }
      const dataFile = path.join(this.dataDir, 'notifications.json');
      const data = Array.from(this.channels.values());
      fs.writeFileSync(dataFile, JSON.stringify(data, null, 2));
    } catch (error) {
      console.error('‚ùå Error saving notification channels:', error);
    }
  }

  async getAllChannels(): Promise<NotificationChannel[]> {
    return Array.from(this.channels.values());
  }

  async getChannelById(id: string): Promise<NotificationChannel | null> {
    return this.channels.get(id) || null;
  }

  async addChannel(channel: NotificationChannel): Promise<NotificationChannel> {
    // ID generation logic moved to Manager or Repo? 
    // Usually Repo generates ID if DB. JSON repo needs to generate it if not present.
    // NOTE: NotificationManager calls addChannel with Omit<Channel, 'id'>.
    // Interface says addChannel(channel: NotificationChannel).
    // So caller must provide ID or we refactor Interface to take Omit?
    // Let's assume Caller generates ID for now or we make ID optional in Interface?
    // Standard Repo pattern: `add(entity)` -> Entity usually has ID or returns Entity with ID.
    // I will stick to Input having ID for simplicity across SQL (auto-inc) and JSON.
    // Wait, SQL auto-inc generates ID. So input shouldn't have ID.
    // Interface should be `addChannel(channel: Omit<NotificationChannel, 'id'>): Promise<NotificationChannel>`.
    
    // Changing Interface requires updating `INotificationRepository.ts`.
    // Let's assume the passed `channel` object ALREADY has an ID generated by Manager if it's JSON?
    // No, SQL needs to ignore it or use it.
    // Proper way: `addChannel(channel: Omit<NotificationChannel, 'id'>)`.
    // I will update interface later if needed, but for now let's treat `NotificationChannel` as the full object.
    // Actually, SQL `id` is INT, JSON `id` is String (Date.now()).
    // This is a type mismatch potential.
    // `NotificationChannel` type says `id: string`.
    // In SQL I defined `id INT AUTO_INCREMENT`.
    // This will conflict.
    // I must either change SQL to VARCHAR and generate IDs in code, OR change Type to string|number.
    // Given the simplicity, I will change SQL to use `id` as `VARCHAR(255)`?
    // No, auto-increment is nice.
    // But `id` in Typescript is string.
    // I will convert SQL ID (number) to string when reading.
    
    // For `addChannel`:
    // If I use SQL auto-inc, I don't pass ID.
    // So `addChannel` should take `Omit<NotificationChannel, 'id'>`.
    
    this.channels.set(channel.id, channel);
    this.saveChannels();
    return channel;
  }

  async updateChannel(id: string, updates: Partial<NotificationChannel>): Promise<NotificationChannel> {
    const channel = this.channels.get(id);
    if (!channel) throw new Error('Channel not found');

    const updated = { ...channel, ...updates };
    this.channels.set(id, updated);
    this.saveChannels();
    return updated;
  }

  async deleteChannel(id: string): Promise<void> {
    if (this.channels.delete(id)) {
      this.saveChannels();
    }
  }
}
